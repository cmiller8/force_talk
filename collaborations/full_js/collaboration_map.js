// Generated by CoffeeScript 1.3.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  $(function() {
    var center_nodes, circle, color_for, cores, current_color_type, current_labs, current_show_type, current_sort_type, data, disciplines, display_edge_table, edge_counts, fill20, fill_dis, fill_lab, force, h, hide_edges, highlight_links, importance, inner_circle_cutoff, inner_radius, link, link_color, node, node_group, node_links, old_labs, outer_radius, r, radial_location, set_centers, setup_bounding_box, setup_edge_counts, setup_edges, setup_nodes, spiral_layout, spiral_location, stroke_opacity, stroke_width, tick_count, update_key, vis, w,
      _this = this;
    disciplines = {
      "abmayr lab": "development",
      "baumann lab": "chromosome dynamics",
      "blanchette lab": "rna",
      "conaway lab": "transcription",
      "gerton lab": "chromosome dynamics",
      "gibson lab": "development",
      "hawley lab": "chromosome dynamics",
      "jaspersen lab": "chromosome dynamics",
      "krumlauf lab": "development",
      "li l lab": "stem cells",
      "li r lab": "cell biology",
      "mak lab": "lipid metabolism",
      "piotrowski lab": "development",
      "sanchez lab": "stem cells",
      "shilatifard lab": "transcription",
      "si lab": "neurobiology",
      "trainor lab": "development",
      "workman lab": "transcription",
      "xie lab": "stem cells",
      "yu lab": "neurobiology",
      "zeitlinger lab": "transcription"
    };
    current_labs = {
      "abmayr lab": true,
      "baumann lab": true,
      "blanchette lab": true,
      "conaway lab": true,
      "gerton lab": true,
      "gibson lab": true,
      "hawley lab": true,
      "jaspersen lab": true,
      "krumlauf lab": true,
      "li l lab": true,
      "li r lab": true,
      "mak lab": true,
      "shilatifard lab": true,
      "si lab": true,
      "trainor lab": true,
      "workman lab": true,
      "xie lab": true,
      "yu lab": true,
      "zeitlinger lab": true
    };
    old_labs = {
      "coffman lab": true,
      "cowan lab": true,
      "du lab": true,
      "pourquie lab": true,
      "eggan lab": true,
      "sauer lab": true,
      "golic lab": true,
      "davidson 1 lab": true,
      "davidson lab": true
    };
    cores = {
      "cytometry facility": true,
      "research advisor": true,
      "kulesa imaging": true,
      "proteomics center": true,
      "bioinformatics center": true,
      "molecular biology facility": true,
      "histology facility": true,
      "microscopy center": true,
      "reptile & aquatics facility": true,
      "tissue culture facility": true,
      "laboratory animal services": true,
      "president emeritus": true
    };
    importance = {
      "robert krumlauf": 2,
      "susan abmayar": 2,
      "peter baumann": 2,
      "marco blanchette": 2,
      "joan conaway": 2,
      "ronald conaway": 2,
      "jennifer gerton": 2,
      "matthew gibson": 2,
      "r hawley": 2,
      "sue jaspersen": 2,
      "linheng li": 2,
      "rong li": 2,
      "ho mak": 2,
      "tatjana piotrowski": 2,
      "alejandro sanchez": 2,
      "ali shilatifard": 2,
      "kausik si": 2,
      "paul trainor": 2,
      "jerry workman": 2,
      "ting xie": 2,
      "ron yu": 2,
      "julia zeitlinger": 2,
      "paul kulesa": 2,
      "arcady mushegian": 2,
      "michael washburn": 2,
      "william neaves": 2,
      "leanne wiedemann": 2,
      "kevin eggan": 2,
      "chunying du": 2,
      "james coffman": 2,
      "brian sauer": 2,
      "susan abmayr": 2,
      "olivier pourquie": 2,
      "chad cowan": 2
    };
    d3.select("#generate").on("click", writeDownloadLink);
    w = 960;
    h = 900;
    r = 6;
    stroke_opacity = 0.6;
    stroke_width = 0.8;
    inner_circle_cutoff = 13;
    link_color = "#ddd";
    outer_radius = w / 2;
    inner_radius = w / 4;
    circle = d3.svg.line.radial().radius(w / 2).angle(function(d) {
      return d;
    });
    radial_location = function(v, rad) {
      var x, y;
      x = (w / 2) + rad * Math.cos(v * Math.PI / 180);
      y = (h / 2) + rad * Math.sin(v * Math.PI / 180);
      return [x, y];
    };
    spiral_location = function(rad, theta) {
      var x, y;
      x = (w / 2) + rad * Math.cos(v * Math.PI / 180);
      y = (h / 2) + rad * Math.sin(v * Math.PI / 180);
      return [x, y];
    };
    data = null;
    center_nodes = {};
    edge_counts = {};
    node = [];
    node_group = null;
    link = [];
    node_links = {};
    force = null;
    tick_count = 0;
    current_color_type = "group";
    current_show_type = "current";
    current_sort_type = "size";
    fill20 = d3.scale.category20();
    fill_lab = d3.scale.category10();
    fill_dis = d3.scale.category10();
    vis = d3.select("#vis").append("svg").attr("id", "vis-svg").attr("width", w).attr("height", h);
    vis.append("rect").attr("width", w).attr("height", h).attr("fill", "none").attr("pointer-events", "all");
    force = d3.layout.force().charge(-20).size([w, h]).linkDistance(50);
    setup_bounding_box = function(d, i, dom_element) {
      var bBox, box, msg, personal_links, tooltipWidth;
      bBox = dom_element.getBBox();
      box = {
        "height": bBox.height,
        "width": bBox.width,
        "x": bBox.x,
        "y": bBox.y
      };
      box.x = Math.round(box.x) + 0;
      box.y = Math.round(box.y) + 0;
      box.width = Math.round(box.width);
      box.height = Math.round(box.height);
      personal_links = node_links[d.name_hash];
      if (personal_links) {
        highlight_links(personal_links, true);
      }
      tooltipWidth = parseInt(d3.select('#tooltip').style('width').split('px').join(''));
      msg = '<table>';
      msg += '<tr><td>' + d["first_name"] + ' ' + d["last_name"] + '</td></tr>';
      msg += '<tr><td>' + d["group"] + '</td></tr>';
      if (personal_links) {
        msg += '<tr><td>' + personal_links[0].length + ' connections' + '</td></tr>';
      }
      msg += '</table>';
      d3.select('#tooltip').classed('hidden', false);
      d3.select('#tooltip .content').html(msg);
      d3.select('#tooltip').style('left', box.x + Math.round(box.width / 2) - (tooltipWidth / 2) - 4 + 'px').style('top', box.y + (box.height / 3) + 25 + 'px');
      return d3.select('#box').style('left', box.x + 'px').style('top', box.y + 'px').style('width', box.width + 'px').style('height', box.height + 'px').classed('hidden', false);
    };
    hide_edges = function(edges) {
      return edges.attr("stroke-opacity", 0).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
    };
    color_for = function(type, d) {
      var dis, _ref;
      if (type === "group") {
        return fill20(d.group);
      } else if (type === "function") {
        type = cores[d.group] ? "core" : "lab";
        return fill_lab(type);
      } else if (type === "discipline") {
        dis = (_ref = disciplines[d.group]) != null ? _ref : "other";
        return fill_dis(dis);
      } else {
        return fill20(d.group);
      }
    };
    update_key = function(type) {
      var active_groups, diss, key_data, key_h, key_r, key_w, keys, keys_vis;
      key_data = [];
      if (type === "group") {
        active_groups = [];
        if (current_show_type === "current") {
          active_groups = d3.merge([d3.keys(current_labs), d3.keys(cores)]);
        } else if (current_show_type === "all") {
          active_groups = d3.merge([d3.keys(current_labs), d3.keys(old_labs), d3.keys(cores)]);
        } else if (current_show_type === "labs_only") {
          active_groups = d3.merge([d3.keys(current_labs)]);
        } else if (current_show_type === "cores_only") {
          active_groups = d3.merge([d3.keys(cores)]);
        } else {
          active_groups = d3.merge([d3.keys(current_labs), d3.keys(old_labs), d3.keys(cores)]);
        }
        key_data = active_groups.map(function(d) {
          return {
            "group": d,
            "name": d,
            "color": fill20(d)
          };
        });
      } else if (type === "function") {
        key_data = [
          {
            "group": "bioinformatics center",
            "name": "core",
            "color": fill_lab("core")
          }, {
            "group": "lab",
            "name": "lab",
            "color": fill_lab("lab")
          }
        ];
      } else if (type === "discipline") {
        diss = {};
        d3.values(disciplines).forEach(function(d) {
          return diss[d] = true;
        });
        key_data = d3.keys(diss).map(function(d) {
          return {
            "name": d,
            "color": fill_dis(d)
          };
        });
        key_data = d3.merge([
          key_data, [
            {
              "name": "other",
              "color": fill_dis("other")
            }
          ]
        ]);
      } else {
        key_data = [];
      }
      key_w = 220;
      key_h = 30;
      key_r = 15;
      d3.select("#key").selectAll('.key').remove();
      keys = d3.select("#key").selectAll('.key').data(key_data).enter().append('div').attr('class', 'key');
      keys_vis = keys.append("svg").attr("width", key_w).attr("height", key_h).append("g").attr("transform", "translate(" + key_r + "," + key_r + ")");
      keys_vis.append("circle").attr("r", 5).attr("fill", function(d) {
        return d.color;
      });
      return keys_vis.append("text").attr("class", "key_title").text(function(d) {
        return d.name;
      }).attr("dy", (key_r / 2) - 3).attr("dx", key_r);
    };
    root.color_nodes = function(type) {
      current_color_type = type;
      node.each(function(d) {
        return d3.select(this).style("fill", function(d) {
          return color_for(current_color_type, d);
        });
      });
      return update_key(current_color_type);
    };
    root.show_groups = function(type) {
      setup_nodes(type);
      setup_edges();
      setup_edge_counts();
      current_show_type = type;
      root.move_groups(current_sort_type);
      return update_key(current_color_type);
    };
    root.move_groups = function(type) {
      current_sort_type = type;
      hide_edges(link);
      set_centers(type);
      tick_count = 0;
      return force.start();
    };
    root.find_nodes = function(search_term) {
      var found_nodes;
      return found_nodes = node.each(function(d) {
        var full_name, match;
        match = -1;
        if (search_term.length > 0) {
          full_name = d.first_name + ' ' + d.last_name;
          match = full_name.toLowerCase().search(new RegExp(search_term.toLowerCase()));
        }
        if (match < 0) {
          return d3.select(this).style("fill", function(d) {
            return color_for(current_color_type, d);
          }).attr("stroke-width", 0).attr("stroke-opacity", 0.0);
        } else {
          return d3.select(this).style("fill", "#F38630").attr("stroke", "#444").attr("stroke-width", 2.5).attr("stroke-opacity", 1.0);
        }
      });
    };
    setup_nodes = function(type) {
      var filter_data;
      filter_data = data.nodes;
      if (type === "current") {
        filter_data = filter_data.filter(function(d) {
          return !old_labs[d["group"]];
        });
      }
      if (type === "labs_only") {
        filter_data = filter_data.filter(function(d) {
          return !old_labs[d["group"]] && !cores[d["group"]];
        });
      }
      if (type === "cores_only") {
        filter_data = filter_data.filter(function(d) {
          return !old_labs[d["group"]] && cores[d["group"]];
        });
      }
      if (type === "pi_only") {
        filter_data = filter_data.filter(function(d) {
          var key;
          key = d.first_name.toLowerCase() + " " + d.last_name.toLowerCase();
          return importance[key] && !old_labs[d["group"]];
        });
      }
      force.nodes(filter_data);
      node = node_group.selectAll("circle.node").data(filter_data, function(d) {
        return d["name_hash"];
      });
      node.enter().append("circle").attr("class", "node").attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).attr("r", function(d) {
        var key, weight, _ref;
        key = d.first_name.toLowerCase() + " " + d.last_name.toLowerCase();
        weight = (_ref = importance[key]) != null ? _ref : 1;
        return 5 * weight;
      }).style("fill", function(d) {
        return color_for(current_color_type, d);
      });
      node.on("mouseover", function(d, i) {
        return setup_bounding_box(d, i, this);
      });
      node.on("mouseout", function(d, i) {
        var personal_links;
        d3.select('#tooltip').classed('hidden', true);
        d3.select('#box').classed('hidden', true);
        personal_links = node_links[d.name_hash];
        if (personal_links) {
          return highlight_links(personal_links, false);
        }
      });
      node.exit().remove();
      return update_key(current_color_type);
    };
    setup_edges = function() {
      var filter_data;
      filter_data = data.links.filter(function(d) {
        return force.nodes().filter(function(e) {
          return e.name_hash === d.source;
        })[0] && force.nodes().filter(function(e) {
          return e.name_hash === d.target;
        })[0];
      });
      link = vis.selectAll("line.link").data(filter_data);
      link.enter().insert("line", ".node_group").attr("class", "link").attr("stroke", link_color).attr("stroke-opacity", 0).attr("stroke-width", stroke_width);
      return link.exit().remove();
    };
    setup_edge_counts = function() {
      edge_counts = {};
      node_links = {};
      return node.each(function(d) {
        var _name;
        node_links[d.name_hash] = vis.selectAll('line.link').filter(function(l) {
          return l.source === d.name_hash || l.target === d.name_hash;
        });
        edge_counts[_name = d.group] || (edge_counts[_name] = 0);
        return edge_counts[d.group] += node_links[d.name_hash][0].length;
      });
    };
    spiral_layout = function() {
      var inc, pos, rad, rad_inc, sorted_keys, sorted_links;
      sorted_links = d3.entries(node_links).sort(function(a, b) {
        return b.value[0].length - a.value[0].length;
      });
      sorted_keys = sorted_links.map(function(d) {
        return d.key;
      });
      rad = 12;
      pos = 0;
      inc = 8;
      rad_inc = 2;
      return sorted_keys.forEach(function(key, i) {
        var x_y;
        x_y = radial_location(pos, rad);
        center_nodes[key] = {
          x: x_y[0],
          y: x_y[1]
        };
        pos += inc;
        rad_inc = i > 20 ? 2 : 6;
        return rad += rad_inc;
      });
    };
    set_centers = function(type) {
      var groups, inner_count, inner_group, inner_increment, inner_pos, outer_group, outer_increment, outer_pos, sorted_counts;
      inner_group = [];
      outer_group = [];
      center_nodes = {};
      if (type === "spiral") {
        spiral_layout();
      } else if (type === "edge") {
        sorted_counts = d3.entries(edge_counts).sort(function(a, b) {
          return b.value - a.value;
        });
        inner_count = sorted_counts.length > 13 ? 12 : 6;
        inner_group = sorted_counts.slice(0, inner_count).map(function(c) {
          return c.key;
        });
        outer_group = sorted_counts.slice(inner_count).map(function(c) {
          return c.key;
        });
      } else if (type === "lab_core") {
        inner_group = d3.keys(cores);
        outer_group = d3.keys(current_labs);
        if (current_show_type === "all") {
          outer_group = d3.merge([outer_group, d3.keys(old_labs)]);
        }
      } else {
        groups = {};
        node.each(function(d) {
          var _name;
          groups[_name = d.group] || (groups[_name] = 0);
          return groups[d.group] += 1;
        });
        inner_group = d3.keys(groups).filter(function(key) {
          return groups[key] > inner_circle_cutoff;
        });
        outer_group = d3.keys(groups).filter(function(key) {
          return groups[key] <= inner_circle_cutoff;
        });
      }
      if (type !== "spiral") {
        inner_pos = -90;
        inner_increment = 360 / inner_group.length;
        inner_group.forEach(function(key) {
          var x_y;
          x_y = radial_location(inner_pos, inner_radius);
          center_nodes[key] = {
            x: x_y[0],
            y: x_y[1]
          };
          return inner_pos += inner_increment;
        });
        outer_pos = -160;
        outer_increment = 360 / outer_group.length;
        return outer_group.forEach(function(key, i) {
          var x_y;
          x_y = radial_location(outer_pos, outer_radius);
          center_nodes[key] = {
            x: x_y[0],
            y: x_y[1]
          };
          return outer_pos += outer_increment;
        });
      }
    };
    highlight_links = function(edges, on_off) {
      if (on_off) {
        return edges.attr('stroke', '#F38630').attr("stroke-width", 1.2).attr("stroke-opacity", 0.8);
      } else {
        return edges.attr('stroke', link_color).attr("stroke-width", stroke_width).attr("stroke-opacity", stroke_opacity);
      }
    };
    display_edge_table = function(edges, nodes, current_node_index) {
      var titles;
      titles = '<table id=\'link_table\'><tr><th>Paper</th><th>Connection</th>';
      edges.each(function(l) {
        var connection_index, connection_node;
        connection_index = l.source === current_node_index ? l.target : l.source;
        connection_node = nodes[connection_index];
        titles += '<tr><td>' + l['title'] + '</td>';
        return titles += '<td>' + connection_node.first_name + ' ' + connection_node.last_name + '</td></tr>';
      });
      titles += '</table>';
      return d3.select('#titles').html(titles);
    };
    return d3.json("data/links_and_nodes_name_hash.json", function(json) {
      var add_edges;
      data = json;
      node_group = vis.append('g').attr('class', 'node_group');
      setup_nodes(current_show_type);
      setup_edges();
      setup_edge_counts();
      set_centers(current_sort_type);
      add_edges = function() {
        return link.attr("stroke-opacity", stroke_opacity).attr("x1", function(d) {
          return force.nodes().filter(function(e) {
            return e.name_hash === d.source;
          })[0].x;
        }).attr("y1", function(d) {
          return force.nodes().filter(function(e) {
            return e.name_hash === d.source;
          })[0].y;
        }).attr("x2", function(d) {
          return force.nodes().filter(function(e) {
            return e.name_hash === d.target;
          })[0].x;
        }).attr("y2", function(d) {
          return force.nodes().filter(function(e) {
            return e.name_hash === d.target;
          })[0].y;
        });
      };
      force.start();
      return force.on('tick', function(e) {
        var k;
        k = e.alpha * .1;
        node.each(function(d, i) {
          var center_node;
          center_node = current_sort_type !== "spiral" ? center_nodes[d.group] : center_nodes[d.name_hash];
          if (center_node) {
            d.x += (center_node.x - d.x) * k;
            d.y += (center_node.y - d.y) * k;
            if (tick_count % 2 === 0) {
              d3.select(this).attr('cx', d.x);
              return d3.select(this).attr('cy', d.y);
            }
          }
        });
        tick_count += 1;
        if (tick_count > 100) {
          force.stop();
          return add_edges();
        }
      });
    });
  });

}).call(this);
